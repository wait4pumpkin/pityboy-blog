## 总结

题目的时间和内存约束是根据C/C++设置的，用其他语言有可能无法达到题目要求。

注意题目的约束条件

段错误一般是数组越界

---

## 题目分类
1. 输入输出
	* [Q1001](#q1001)
	* [Q1002](#q1002)
	* [Q1005](#q1005)
	* [Q1062](#q1062)
	* [Q1069](#q1069)
	* [Q1070](#q1070)

2. 字符串处理
	* [Q1061](#q1061)

3. 数组操作
	* [Q1042](#q1042)
	* [Q1067](#q1067)
	
5. 基本数据结构
	* [Q1063](#q1063)

6. 最短路径算法
	* [Q1003](#q1003)
	* [Q1072](#q1072)

7. 树的构建
	* [Q1004](#q1004)
	* [Q1043](#q1043)
	* [Q1064](#q1064)
	* [Q1066](#q1066)

---

## <span id="q1001">Q1001</span>
十分基础的输入输出题

---

## <span id="q1002">Q1002</span>
简单输入输出题，用数组索引系数即可，注意数组不要越界

---

## <span id="q1003">Q1003</span>
一道最短路径的题目，但需要保存所有可能的最短路径，所以每个点的前驱不是单个，而是set。最后再回溯所有最短路径，并根据题目意思输出最优路径。

---

## <span id="q1004">Q1004</span>
首先根据输入的父子关系重构树，在构造过程中记录每个节点的level。然后根据level排序，最后统计每个level的叶子数。

---

## <span id="q1005">Q1005</span>
简单输入输出题

---

## <span id="q1042">Q1042</span>
按照指定的次序重新排列数组，关键在于理解好题目，第i位的数字j表示把原序列中的第i张牌移到第j处。

---

## <span id="q1043">Q1043</span>
给定先根遍历续，判断是否合法的二叉树。首先要构建二叉树，第一个输出的必定为根，顺序遍历直到发现比根大的，该位置之前的是左子树，该位置（包括该位置）之后的为右子树。每课子树再重复该步骤。构建好树之后中序遍历一遍，合法的二叉树输出应该是升序的。Mirror的情况再做一遍即可。

---

## <span id="q1061">Q1061</span>
字符串遍历和比较，关键是理解好题目的意思。

---

## <span id="q1062">Q1062</span>
按题目意思保存好数据，然后排序输出即可。

---

## <span id="q1063">Q1063</span>
set的基本操作，交集和并集，直接使用stl的algorithm即可。

---

## <span id="q1064">Q1064</span>
完全二叉树的构建，首先把给定的序列排序，根据左右子树与根的关系，以及完全二叉树的高度，确定好根的位置，然后递归构建左右子树。简而言之，就是在排序好的序列中找到根的位置。构建好树之后，用BFS输出树的层次序。

---

## <span id="q1065">Q1065</span>
长整数运算，直接计算会溢出，用Java的BigInteger可以直接无视。如果不想水就要根据溢出条件来判断，同号时才会溢出，溢出后会变号，而三个数原来都是64位存储的，根据这些信息可以判断。

---

## <span id="q1066">Q1066</span>
AVL树的构建，首先实现左旋和右旋操作，旋转时注意子树的处理。每个结点增加子树高度记录，旋转和插入后要更新高度。插入操作使用普通二叉树的递归插入，每次递归插入后根据插入的是左子树还是右子树，以及是左子树高还是右子树高，共四种情况旋转，其中两种情况需要旋转一次，两种需要旋转两次。这题比较考代码功底和现场调试能力。

---

## <span id="q1067">Q1067</span>
基本思路，如果第0位不是0，则把第0位的数放到正确位置，若第0位是0，则把0与第一位乱序的数交换。重复以上步骤至所有已排序好。注意输入的第一个数字是序列长度，一开始没认真看题目想了很久。

---

## <span id="q1068">Q1068</span>
动态规划题目，典型的01背包，注意初始化以及临界点，即单个的情况。同时为了取得最小序列，一开始对整个序列降序排序，则回溯时可获得最小序列。

---

## <span id="q1069">Q1069</span>
按题目意思排序相减即可，注意输入6174也要输出一行，而且输出的整数要补齐四位。

---

## <span id="q1070">Q1070</span>
按照题目意思取输入后，按单价排序，然后单价高的先取。注意题目给出的例子是整数，但测试用例里有浮点数。

---

## <span id="q1072">Q1072</span>
根据题意建好图，然后每个Station的点跑一次Dijkstra，并根据题目的判决标准选最优。
要理解好题目，要求House到Station的最小距离最大。
最关键的地方是，题目给出的例子浮点数是四舍五入的，是实际判决是直接截断。